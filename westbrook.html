<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8">
  <link href="http://getbootstrap.com/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="http://getbootstrap.com/examples/justified-nav/justified-nav.css" rel="stylesheet">
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.0.3.min.js"></script>
  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  <style>
    .label {
      font: 20px Verdana;
    }

    .axis text {
      font: 10px sans-serif;
    }

    .axis line,
    .axis path {
      fill: none;
      stroke: black;
      shape-rendering: crispEdges;
    }

    .grid .tick {
        stroke: lightgrey;
        stroke-opacity: 0.7;
        shape-rendering: crispEdges;
    }

    .tooltip {
      position: absolute;
      width: 150px;
      height: 70px;
      pointer-events: none;
      background-color: white;
      stroke: black;
      color: black;
    }

    .game {
      stroke: black;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="row">
      <div class="col-xs-12">
        <svg id="bigNumber"/>
        <svg id="timeline" />
        <div class="row">
          <div class="col-xs-4">
            <svg id="game" />
          </div>
          <div class="col-xs-4">
            <svg id="web" />
          </div>
          <div class="col-xs-4">
            <svg id="average" />
          </div>
        </div>
      </div>
    </div>
  </div>
  <br />
  <!--<input type="text" value="81" id="gamesInSeason">
  http://stats.nba.com/stats/leaguegamefinder?Conference=&DateFrom=&DateTo=&Division=&DraftNumber=&DraftRound=&DraftYear=&GB=N&LeagueID=00&Location=&Outcome=&PlayerID=201566&PlayerOrTeam=P&Season=2016-17&SeasonType=Regular+Season&StatCategory=PTS&TeamID=&VsConference=&VsDivision=&VsTeamID=
  <button onclick="return recount();">Пересчитать</button>-->
  <script type="text/javascript">
    var parseDate = function(input) {
      var parts = input.split('-');
      // new Date(year, month [, day [, hours[, minutes[, seconds[, ms]]]]])
      return new Date(parts[0], parts[1]-1, parts[2]); // Note: months are 0-based
    }

    var getDateFormat = function(date) {
      return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate()
    }
    // http://colorbrewer2.org/
    var blues = {
      3:['#deebf7', '#9ecae1', '#3182bd'],
      4:['#eff3ff', '#bdd7e7', '#6baed6', '#2171b5'],
      5:['#eff3ff', '#bdd7e7', '#6baed6', '#3182bd', '#08519c'],
      6:['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#3182bd', '#08519c'],
      7:['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#084594'],
      8:['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#084594'],
      9:['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b']
    };
    var reds = {
      3:['#fee0d2', '#fc9272', '#de2d26'],
      4:['#fee5d9', '#fcae91', '#fb6a4a', '#cb181d'],
      5:['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15'],
      6:['#fee5d9', '#fcbba1', '#fc9272', '#fb6a4a', '#de2d26', '#a50f15'],
      7:['#fee5d9', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#99000d'],
      8:['#fff5f0', '#fe e0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#99000d'],
      9:['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d']
    };
    var
      margin = { top: 40, right: 40, bottom: 40, left: 40 },
      nbaBlue = '#006bb6',
      nbaRed = '#ed174c',
      okBlue = '#397cb0',
      okYellow = '#faac3d',
      dashBoardHeight = 200,
      dashBoardWidth = 300;
    
    // add the tooltip area to the webpage
    // code from here http://bl.ocks.org/weiglemc/6185069
    var tooltip = d3
      .select('body')
      .append('div')
      .attr({ class: 'tooltip' })
      .style({ opacity: 0 });

    var bn = d3.select('#bigNumber'),
      BN_WIDTH = 700,
      BN_HEIGHT = 200;
    bn
      .attr({
        width: BN_WIDTH,
        height: BN_HEIGHT
      });
    bn
      .append('text')
      .attr({
        x: BN_WIDTH / 2 + margin.left - 3,
        y: margin.top + margin.bottom - 10,
        dy: '.6em',
      })
      .style({
        'text-anchor': 'start',
        'font-size': '110'
      });

    var
      WIDTH = 900,
      HEIGHT = 300,
      width = WIDTH - margin.left - margin.right,
      height = HEIGHT - margin.top - margin.bottom;

    // sample from https://bl.ocks.org/mbostock/4149176
    var customTimeFormat = d3.time.format.multi([
      [ '.%L', function(d) { return d.getMilliseconds(); } ],
      [ ':%S', function(d) { return d.getSeconds(); } ],
      [ '%I:%M', function(d) { return d.getMinutes(); } ],
      [ '%I %p', function(d) { return d.getHours(); } ],
      [ '%a %d', function(d) { return d.getDay() && d.getDate() != 1; } ],
      [ '%b %d', function(d) { return d.getDate() != 1; } ],
      [ '%B', function(d) { return d.getMonth(); } ],
      [ '%Y', function() { return true; } ]
    ]);

    var xValue = function(d) { return d.date; },
        xScale = d3.time.scale().range([0, width]),
        xMap = function(d) { return xScale(xValue(d)); },
        xAxis = d3.svg.axis().scale(xScale).tickFormat(customTimeFormat);
    var yValue = function(d) { return d.isTD ? d.tdStreak : -1 * d.notTDStreak; },
        yScale = d3.scale.linear().range([height, 0]),
        yMap = function(d) { return yScale(yValue(d)); },
        yAxis = d3.svg.axis().scale(yScale);
    var rValue = function(d) {
      return 5;  // * (d.isTD ? d.tdStreak : d.notTDStreak);
    };
    var cValue = function(d) {
      if (d.isTD) {
        return nbaRed;
      } else {
        return nbaBlue;
      }
    };
    var opacityValue = function(d) {
      return ((d.isTD ? d.tdStreak : d.notTDStreak) / 2 + 7) / 10
    };
    // donut chart from here https://bl.ocks.org/mbostock/3887193
    var radius = BN_HEIGHT / 2;
    var arcBlue = d3.svg.arc()
        .outerRadius(radius - 5)
        .innerRadius(radius - 10);
    var arcYellow = d3.svg.arc()
        .outerRadius(radius - 17)
        .innerRadius(radius - 22);
    // transparent color idea from here https://developers.google.com/chart/interactive/docs/gallery/piechart
    var pie = d3.layout.pie()
        .sort(null)
        .value(function(d) { return d.value; });
    var makeXAxisGrid = function() {
      return d3.svg.axis()
        .scale(xScale)
        .orient('bottom');
    }
    var textByValue = function(number) {
      if (number >= 11 && number <= 19) {
        return 'трипл-даблов';
      }
      var mod = number % 10;
      switch (mod) {
        case 1:
          return 'трипл-дабл';
        case 2:
        case 3:
        case 4:
          return 'трипл-дабла';
        default:
          return 'трипл-даблов';      
      }
    }

    var svg = d3
      .select('#timeline')
      .attr({
        width: width + margin.left + margin.right,
        height: height + margin.top + margin.bottom
      })
      .append('g')
      .attr({
        transform: 'translate(' + margin.left + ',' + margin.top + ')'
      });

    svg
      .append('rect')
      .attr({
        x: - margin.left / 2,
        y: -1,
        width: width + margin.left,
        height: height / 2,
        fill: nbaBlue,
      });
    svg
      .append('rect')
      .attr({
        x: - margin.left / 2,
        y: height / 2,
        width: width + margin.left,
        height: height / 2,
        fill: nbaRed,
      });

    var data = null;

    var totalGames = 0,
        totalPoints = 0,
        totalRebounds = 0,
        totalAssists = 0,
        totalSteals = 0,
        totalBlocks = 0,
        totalTD = 0,
        currenttdStreak = 0,
        currentNottdStreak = 0,
        totalHomeTD = 0,
        totalWinTD = 0;

    var getGamesInfo = function(d) {
      var gamesNumber = d[0].headers.indexOf('MATCHUP')
        , wlNumber = d[0].headers.indexOf('WL')
        , pointsNumber = d[0].headers.indexOf('PTS')
        , reboundsNumber = d[0].headers.indexOf('REB')
        , dateNumber = d[0].headers.indexOf('GAME_DATE')
        , blocksNumber = d[0].headers.indexOf('BLK')
        , stealsNumber = d[0].headers.indexOf('STL')
        , assistsNumber = d[0].headers.indexOf('AST');

      var result = [];
      d[0].rowSet.reverse().forEach(function(game, index) {
        var resultG = {
          id: index + 1,
          name: game[gamesNumber],
          wl: game[wlNumber] == 'W',
          points: game[pointsNumber],
          rebounds: game[reboundsNumber],
          assists: game[assistsNumber],
          blocks: game[blocksNumber],
          steals: game[stealsNumber],
          date: parseDate(game[dateNumber]),
          isTD: (game[pointsNumber] >= 10 && game[reboundsNumber] >= 10 && game[assistsNumber] >= 10),
          atHome: game[gamesNumber].indexOf('@') == -1
        };

        if (resultG.isTD) {
          if (currentNottdStreak) {
            currentNottdStreak = 0;
            currenttdStreak = 1;
          } else {
            currenttdStreak += 1;
          }
        } else {
          if (currenttdStreak) {
            currenttdStreak = 0;
            currentNottdStreak = 1;
          } else {
            currentNottdStreak += 1;
          }
        }

        totalGames += 1;
        totalPoints += resultG.points;
        totalRebounds += resultG.rebounds;
        totalAssists += resultG.assists;
        totalBlocks += resultG.blocks;
        totalSteals += resultG.steals;
        if (resultG.isTD) {
          totalTD += 1;
          totalHomeTD += 1 * resultG.atHome;
          totalWinTD += 1 * resultG.wl;
        }

        resultG.totalGames = totalGames;
        resultG.totalPoints = totalPoints;
        resultG.totalRebounds = totalRebounds;
        resultG.totalAssists = totalAssists;
        resultG.totalSteals = totalSteals
        resultG.totalBlocks = totalBlocks;
        resultG.totalTD = totalTD;
        resultG.tdStreak = currenttdStreak;
        resultG.notTDStreak = currentNottdStreak;

        result.push(resultG);
      });
      return result;
    }

    var uriPlayer = 'http://stats.nba.com/stats/playercareerstats?LeagueID=00&PerMode=Totals&PlayerID=201566';
    var uriGames = 'http://stats.nba.com/stats/leaguegamefinder?GB=N&LeagueID=00&PlayerID=201566&PlayerOrTeam=P&Season=2016-17&SeasonType=Regular+Season&StatCategory=PTS';
    $(document).ready(function() {
      $.ajax({
        url: uriGames,
        type: 'GET',
        dataType: 'jsonp',
        success: function(result) {
          var gamesData = getGamesInfo(result.resultSets);
          var formattedData = getPlayerInfo(data, 82);

          var blueData = [
            { value: totalWinTD, color: okBlue, text: totalWinTD + ' в победных матчах' },
            { value: totalTD - totalWinTD, color: 'transparent', text: '' }
          ];
          var gb = bn
            .selectAll('.arcBlue')
            .data(pie(blueData));
          gb
            .enter()
            .append('g')
            .attr('class', 'arcBlue');
          gb
            .append('path')
            .attr({
              transform: 'translate(' + (margin.left * 2.5 + BN_WIDTH / 2) + ',' +
                                        (margin.top / 7 + BN_HEIGHT / 2) + ') rotate(170)',
              d: arcBlue
            })
            .style('fill', function(d) { return d.data.color; });
          gb.append('text')
            .attr({
              transform: function(d, i) {
                return i == 0 
                  ? 'translate(' + (-margin.left * 4 + BN_WIDTH / 2) + ',' +
                                   (-margin.top * 4 + BN_HEIGHT / 2) + ') translate(' + arcBlue.centroid(d) + ')'
                 : '';
              },
              dy: '.35em'
            })
            .text(function(d) { return d.data.text; });

          var yellowData = [
            { value: totalHomeTD, color: okYellow, text: totalHomeTD + ' в домашних играх' },
            { value: totalTD - totalHomeTD, color: 'transparent', text: '' }
          ];
          var gy = bn
            .selectAll('.arcYellow')
            .data(pie(yellowData));
          gy
            .enter()
            .append('g')
            .attr('class', 'arcYellow');
          gy
            .append('path')
            .attr({
              transform: 'translate(' + (margin.left * 2.5 + BN_WIDTH / 2) + ',' + (margin.top / 7 + BN_HEIGHT / 2) + ') rotate(30)',
              d: arcYellow
            })
            .style('fill', function(d) { return d.data.color; });
          gy.append('text')
            .attr({
              transform: function(d, i) { 
                return i == 0 
                  ? 'translate(' + (margin.left * 2 + BN_WIDTH / 2) + ',' +
                                   (margin.top * 1.3 + BN_HEIGHT / 2) + ') translate(' + arcYellow.centroid(d) + ')'
                  : '';
              },
              dy: '.35em'
            })
            .text(function(d) { return d.data.text; });

          bn
            .select('text')
            .text(totalTD);
          bn
            .append('text')
            .attr({
              x: BN_WIDTH / 2 + margin.left * 1.6,
              y: margin.top * 3 + margin.bottom - 5,
              dy: '.35em',
            })
            .text(textByValue(totalTD));

          xScale.domain([d3.min(gamesData, xValue), d3.max(gamesData, xValue)]);
          yScale.domain([-1 * d3.max(gamesData, yValue) - 1, d3.max(gamesData, yValue) + 1]);

          svg
            .append('g')
            .attr({
              class: 'grid',
              transform: 'translate(0,' + height + ')'
            })
            .call(makeXAxisGrid()
              .tickSize(-height, 0, 0)
              .tickFormat('')
            );

          svg
            .append('text')
            .attr({
              x: -margin.left / 3,
              y: margin.top / 3,
              dy: '.35em',
              fill: 'white',
            })
            .style('text-anchor', 'start')
            .text('Трипл-дабл');
          svg
            .append('text')
            .attr({
              x: width - margin.left * 2,
              y: height - margin.top / 3,
              dy: '.35em',
              fill: 'white',
            })
            .style('text-anchor', 'start')
            .text('Обычная игра');

          svg
            .append('g')
            .attr({
              class: 'x axis',
              transform: 'translate(0,' + (height + 5) + ')'
            })
            .call(xAxis);

          var foundGames = svg
            .selectAll('.game')
            .data(gamesData, function(d) { return d.name + d.date; });

          // scatter plot from here
          // http://bl.ocks.org/weiglemc/6185069
          foundGames
            .enter()
            .append('circle')
            .attr({
              r: rValue,
              cx: xMap,
              cy: yMap,
              class: 'game',
              fill: cValue,
              'fill-opacity': opacityValue
            })
            .on('mouseover', function(d) {
              // http://stackoverflow.com/a/23703180/213550
              d3
                .select(this)
                .style({ stroke: '#fff' });

              showAverage(d);
              showGame(d);
              showGameToGo(d);

              tooltip
                .transition()
                .duration(200)
                .style({
                  opacity: 1,
                  stroke: '#fff',
                });
              tooltip
                .html(d.name + ' (' + getDateFormat(d.date) + ')<br />' +
                  '<br />В матче ' + d.points + '-' + d.rebounds + '-' + d.assists +
                  '<br />Всего ' + d.totalPoints + '-' + d.totalRebounds + '-' + d.totalAssists)
                .style({
                  left: (d3.event.pageX + 5) + 'px',
                  top: (d3.event.pageY - 28) + 'px'
                });
            })
            .on('mouseout', function(d) {
              d3
                .select(this)
                .style({ stroke: '#000' });
              tooltip
                .transition()
                .duration(500)
                .style({ opacity: 0 });
            });

          foundGames
            .exit()
            .remove();

          bn
            .append('text')
            .attr({
              x: margin.left,
              y: margin.top + margin.bottom,
              dy: '.35em',
              class: 'label',
            })
            .html(formattedData.name);

          // formatTable(formattedData.total, 'infoTotalLabels', 50, 50, 'name');
          // formatTable(formattedData.total, 'infoTotal', 230, 50, 'value');
          
          // formatTable(formattedData.perGame, 'infoPerGameLabels', 370, 50, 'name');
          // formatTable(formattedData.perGame, 'infoPerGame', 560, 50, 'value');
          
          // formatTable(formattedData.leftToScore, 'infoLeftLabels', 50, 170, 'name');
          // formatTable(formattedData.leftToScore, 'infoLeft', 230, 170, 'value');
          
          // formatTable(formattedData.rythm, 'infoRythmLabels', 370, 170, 'name');
          // formatTable(formattedData.rythm, 'infoRythm', 560, 170, 'value');

          // formatTable(formattedData.perGameLeft, 'infoPerGameLeftLabels', 50, 290, 'name');
          // formatTable(formattedData.perGameLeft, 'infoPerGameLeft', 230, 290, 'value');

        },
        error: function(xhr, ajaxOptions, thrownError) {
          alert(thrownError);
        },
      });
    });

    // var formatTable = function(d, label, startX, startY, name) {
    //   var foundLabels = vis
    //     .selectAll('.' + label)
    //     .data(d, function(d) { return d.name + '' + d.value; });
    //   foundLabels
    //     .enter()
    //     .append('text')
    //     .attr({
    //       x: startX,
    //       y: function(di, i) { return startY + i * 20 + (i != 0) * 5; },
    //       dy: '.35em',
    //       class: 'label'
    //     })
    //     .html(function(di) { return di[name]; });
    //   foundLabels.exit().remove();
    // };

    // simple chart http://bl.ocks.org/d3noob/8952219
    var showAverage = function(gameAv) {
      var gameAvMargins = { left: 20, top: 20, right: 20, bottom: 20, };
      var gameAvWidth = dashBoardWidth - gameAvMargins.left - gameAvMargins.right,
          gameAvHeight = dashBoardHeight - gameAvMargins.top - gameAvMargins.bottom;

      var data = [
        { text: 'Очки', value: gameAv.totalPoints / gameAv.id, name: gameAv.name, date: gameAv.date },
        { text: 'Подборы', value: gameAv.totalRebounds / gameAv.id, name: gameAv.name, date: gameAv.date },
        { text: 'Передачи', value: gameAv.totalAssists / gameAv.id, name: gameAv.name, date: gameAv.date },
      ];
      var xAvGame = d3.scale.ordinal()
        .rangeRoundBands([0, gameAvWidth], .25);
      var yAvGame = d3.scale.linear()
        .range([gameAvHeight, 0]);
      var xAvAxisGame = d3.svg.axis()
        .scale(xAvGame)
        .orient('bottom');
      var yAvAxisGame = d3.svg.axis()
        .scale(yAvGame)
        .orient('left')
        .ticks(0);
      xAvGame.domain(data.map(function(d) { return d.text; }));
      yAvGame.domain([0, d3.max(data, function(d) { return d.value; } )]);
      
      var gameAvV = d3.select('#game');      
      
      gameAvV
        .selectAll('line')
        .remove();
      gameAvV
        .selectAll('text')
        .remove();

      gameAvV
        .attr({
          width: dashBoardWidth,
          height: dashBoardHeight
        })
        .append('g')
        .attr({
          transform: 'translate(' + gameAvMargins.left + ',' + gameAvMargins.top + ')'
        });
      
      gameAvV
        .selectAll('.x')
        .remove();

      gameAvV
        .append('g')
        .attr({
          class: 'x axis',
          transform: 'translate(' + gameAvMargins.left + ',' + (gameAvHeight + gameAvMargins.top) + ')'
        })
        .call(xAvAxisGame);
      
      gameAvV
        .selectAll('.y')
        .remove();

      gameAvV
        .append('g')
        .attr('class', 'y axis')
        .attr('transform', 'translate(' + gameAvMargins.left + ',' + gameAvMargins.top + ')')
        .call(yAvAxisGame)
        .append('text')
        .attr({
          x: -5,
          y: yAvGame(10),
          dy: '.71em',
        })
        .style({
          'font-weight': 'bold',
          'text-anchor': 'end',
        })
        .text('10');

      var gameAvStats = gameAvV
        .selectAll('.barGame')
        .data(data, gamekey);
      var gameAvStatLabels = gameAvV
        .selectAll('.barGameLabel')
        .data(data, gamekey);
      
      gameAvStats
        .enter()
        .append('rect')
        .style('fill', nbaBlue)
        .attr({
          x: function(d) { return xAvGame(d.text) + gameAvMargins.left; },
          y: function(d) { return yAvGame(d.value) + gameAvMargins.top; },
          width: xAvGame.rangeBand(),
          height: function(d) { return gameAvHeight - yAvGame(d.value); },
          class: 'barGame',
        })

      gameAvStatLabels
        .enter()
        .append('text')
        .attr({
          x: function(d) { return xAvGame(d.text) + xAvGame.rangeBand() / 2 + gameAvMargins.left / 2 + (d.value > 10 ? -4 : 0); },
          y: function(d) { return gameAvMargins.top + gameAvMargins.bottom; },
          dy: '.35em',
          class: 'barGameLabel',
          'font-weight': 'bold',
        })
        .text(function(d) { return d.value.toFixed(1); });

      gameAvV
        .append('line')
        .attr({
          x1: gameAvMargins.left,
          x2: dashBoardWidth - gameAvMargins.right,
          y1: Math.floor(yAvGame(10)) + gameAvMargins.top,
          y2: Math.floor(yAvGame(10)) + gameAvMargins.top,
          stroke: nbaRed,
          'stroke-width': 2,
        });
      gameAvV
        .append('text')
        .attr({
          x: dashBoardWidth / 4.77 + gameAvMargins.left,
          y: 5,
          dy: '.35em',
        })
        .style({
          'font-weight': 'bold',
          'text-anchor': 'start',
        })
        .text('В среднем за сезон');

      gameAvStats
        .exit()
        .remove();
      gameAvStatLabels
        .exit()
        .remove();
    }

    // https://www.visualcinnamon.com/2013/09/making-d3-radar-chart-look-bit-better.html
    // https://gist.github.com/nbremer/6506614
    var showGame = function(game) {
      var gameMargins = { left: 30, top: 20, right: 20, bottom: 20, };
      var gameWidth = dashBoardWidth - gameMargins.left - gameMargins.right,
          gameHeight = dashBoardHeight - gameMargins.top - gameMargins.bottom;
      var data = [
        { text: 'Очки', value: game.points },
        { text: 'Подборы', value: game.rebounds },
        { text: 'Блокшоты', value: game.blocks },
        { text: 'Перехваты', value: game.steals },
        { text: 'Передачи', value: game.assists },
      ];
      var webOptions = {
        radius: dashBoardWidth / 2 - gameMargins.top - gameMargins.bottom,
        levels: 4,
        width: dashBoardWidth,
        height: dashBoardHeight,
        radians: 2 * Math.PI,
        factorLegend: 6 / 7,
        opacityArea: 0.3,
        maxValue: Math.max(game.points, game.rebounds, game.blocks, game.steals, game.assists),
      };
      var gameVis = d3.select('#web');

      gameVis
        .selectAll('line')
        .remove();
      gameVis
        .selectAll('polygon')
        .remove();
      gameVis
        .selectAll('text')
        .remove();
      gameVis
        .attr({
          width: webOptions.width,
          height: webOptions.height,
        })
        .append('g')
        .attr({
          transform: 'translate(' + gameMargins.left + ',' + gameMargins.top + ')',
        });

      for (var j = 0; j < webOptions.levels - 1; ++j) {
        var levelFactor = webOptions.radius * ((j + 1) / webOptions.levels);
        var toCenter = 'translate(' + (webOptions.width / 2 - levelFactor) + ', ' + (webOptions.height / 2 - levelFactor) + ')';
        //Circular segments
        gameVis
          .selectAll('.levels')
          .data(data, function(d) { return d.text + '' + j; })
          .enter()
          .append('line')
          .attr({
            x1: function(d, i) { return levelFactor * (1 - Math.sin(i * webOptions.radians / data.length)); },
            y1: function(d, i) { return levelFactor * (1 - Math.cos(i * webOptions.radians / data.length)); },
            x2: function(d, i) { return levelFactor * (1 - Math.sin((i + 1) * webOptions.radians / data.length)); },
            y2: function(d, i) { return levelFactor * (1 - Math.cos((i + 1) * webOptions.radians / data.length)); },
            class: 'line',
            transform: toCenter,
          })
          .style({
            stroke: 'grey',
            'stroke-opacity': .75 + (j + 2) * .05,
            'stroke-width': '0.4px',
          });

        gameVis
          .selectAll('.levels')
          .data([1]) //dummy data
          .enter()
          .append('text')
          .attr({
            x: function(d) { return levelFactor * (1 - Math.sin(Math.PI * webOptions.factorLegend)); },
            y: function(d) { return (10 - j * 2.9) + levelFactor * (1 - Math.cos(Math.PI * webOptions.factorLegend)); },
            class: 'legend',
            transform: toCenter,
            fill: '#737373',
          })
          .style({
            'font-family': 'sans-serif',
            'font-size': '10px',
          })
          .text(((j + 2) * webOptions.maxValue / webOptions.levels).toFixed(1));
      }

      // legend with lines
      var axis = gameVis
        .selectAll('.axis')
        .data(data);
      var axisFactor = webOptions.radius * (webOptions.levels - 1) / webOptions.levels;
      var toCenter = 'translate(' + (webOptions.width / 2 - axisFactor) + ', ' + (webOptions.height / 2 - axisFactor) + ')';

      axis
        .enter()
        .append('g')
        .attr({ class: 'axis' });

      axis
        .append('line')
        .attr({
          x1: webOptions.radius - gameMargins.left + 2,
          y1: dashBoardHeight / 2 - gameMargins.top + 2,
          x2: function(d, i) { return axisFactor * (1 - Math.sin(i * webOptions.radians / data.length)); },
          y2: function(d, i) { return axisFactor * (1 - Math.cos(i * webOptions.radians / data.length)); },
          class: 'line',
          transform: toCenter,
        })
        .style({
          stroke: 'grey',
          'stroke-width': '1.1px',
        });

      var toCenter = 'translate(' + (webOptions.width / 2 - axisFactor) + ', ' + (webOptions.height / 2 - axisFactor - gameMargins.top / 2) + ')';
      axis
        .append('text')
        .attr({
          x: function(d, i) { return axisFactor *
            (1 - Math.sin(i * webOptions.radians / data.length)) - 30 * Math.sin(i * webOptions.radians / data.length); },
          y: function(d, i) { return axisFactor *
            (1 - Math.cos(i * webOptions.radians / data.length)) - 10 * Math.cos(i * webOptions.radians / data.length); },
          class: 'legend',
          dy: '1.5em',
          transform: toCenter,
          //  transform: function(d, i) { return "translate(0, -10)"; },
          'text-anchor': 'middle',
        })
        .style({
          'font-size': '11px',
          'font-family': 'sans-serif',
        })
        .text(function(d) { return d.text });

      axis
        .exit()
        .remove();

      data.forEach(function(d) {
        dataValues = [];
        data.forEach(function(di, i) {
          dataValues.push([
            webOptions.width / 2 * (1 - (di.value / (10 * webOptions.levels)) * Math.sin(i * webOptions.radians / data.length)), 
            webOptions.height / 2 * (1 - (di.value / (10 * webOptions.levels)) * Math.cos(i * webOptions.radians / data.length))
          ]);
        });
        dataValues.push(dataValues[0]);

        gameVis
          .selectAll('.area')
          .data([dataValues])
          .enter()
          .append('polygon')
          .style({
            'fill': okYellow,
            'fill-opacity': webOptions.opacityArea,
            'stroke': okYellow,
            'stroke-width': '2px',
          })
          .attr({
            'class': 'radar-chart-serie',
            'points': function(di) {
              var str = '';
              for (var pti = 0; pti < di.length; ++pti) {
                str = str + di[pti][0] + ',' + di[pti][1] + ' ';
              }
              return str;
            }
          })
          .on('mouseover', function () {
            z = 'polygon.' + d3.select(this).attr('class');
            gameVis
              .selectAll('polygon')
              .transition(200)
              .style('fill-opacity', 0.1); 
            gameVis
              .selectAll(z)
              .transition(200)
              .style('fill-opacity', .7);
          })
          .on('mouseout', function() {
            gameVis
              .selectAll('polygon')
              .transition(200)
              .style('fill-opacity', webOptions.opacityArea);
          });
      });
      gameVis
        .append('text')
        .attr({
          x: gameMargins.left,
          y: 5,
          dy: '.35em',
          width: dashBoardWidth,
        })
        .style({
          'font-weight': 'bold',
          'text-anchor': 'start',
        })
        .text(game.name);
    }

    var gamekey = function(d) {
      return d.text + '|' + d.value + '|' + game.name + '|' + getDateFormat(d.date);
    };

    var showGameToGo = function(gameTG) {
      var gameTGMargins = { left: 30, top: 20, right: 20, bottom: 20, };
      var gameTGWidth = dashBoardWidth - gameTGMargins.left - gameTGMargins.right,
          gameTGHeight = dashBoardHeight - gameTGMargins.top - gameTGMargins.bottom;

      var xGameTG = d3.scale.ordinal()
        .rangeRoundBands([0, gameTGWidth], .25);
      var yGameTG = d3.scale.linear()
        .range([gameTGHeight, 0]);
      var xAxisGameTG = d3.svg.axis()
        .scale(xGameTG)
        .orient('bottom');
      var yAxisGameTG = d3.svg.axis()
        .scale(yGameTG)
        .orient('left')
        .ticks(0);
      var data = [
        { text: 'Очки', value: gameTG.totalPoints, name: gameTG.name, date: gameTG.date },
        { text: 'Подборы', value: gameTG.totalRebounds, name: gameTG.name, date: gameTG.date },
        { text: 'Передачи', value: gameTG.totalAssists, name: gameTG.name, date: gameTG.date },
      ];
      xGameTG.domain(data.map(function(d) { return d.text; }));
      yGameTG.domain([0, 820]);

      var gameTGvis = d3.select('#average');
      
      gameTGvis
        .selectAll('line')
        .remove();
      gameTGvis
        .selectAll('text')
        .remove();

      gameTGvis
        .attr({
          width: dashBoardWidth,
          height: dashBoardHeight
        })
        .append('g')
        .attr({
          transform: 'translate(' + gameTGMargins.left + ',' + gameTGMargins.top + ')'
        });
      gameTGvis
        .append('text')
        .attr({
          x: dashBoardWidth / 1.467 + gameTGMargins.left,
          y: 5,
          dy: '.35em',
        })
        .style({
          'font-weight': 'bold',
          'text-anchor': 'end',
        })
        .text('Трипл-дабл в среднем');
      
      gameTGvis
        .selectAll('.x')
        .remove();

      gameTGvis
        .append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(' + gameTGMargins.left + ',' + (gameTGHeight + gameTGMargins.top) + ')')
        .call(xAxisGameTG);
      
      gameTGvis
        .selectAll('.y')
        .remove();

      gameTGvis
        .append('g')
        .attr('class', 'y axis')
        .attr('transform', 'translate(' + gameTGMargins.left + ',' + gameTGMargins.top + ')')
        .call(yAxisGameTG);

      var gameStatsTG = gameTGvis
        .selectAll('.barGame')
        .data(data, gamekey);
      var gameStatLabelsTG = gameTGvis
        .selectAll('.barGameLabel')
        .data(data, gamekey);
      
      gameStatsTG
        .enter()
        .append('rect')
        .style('fill', okBlue)
        .attr({
          x: function(d) { return xGameTG(d.text) + gameTGMargins.left; },
          y: function(d) { return yGameTG(Math.min(d.value, 820)) + gameTGMargins.top; },
          width: xGameTG.rangeBand(),
          height: function(d) { return gameTGHeight - yGameTG(Math.min(d.value, 820)); },
          class: 'barGame',
        })

      gameStatLabelsTG
        .enter()
        .append('text')
        .attr({
          x: function(d) { return xGameTG(d.text) + xGameTG.rangeBand() / 2 + gameTGMargins.left / 2 + (d.value > 1000 ? -2 : 0); },
          y: function(d) { return gameTGMargins.top + gameTGMargins.bottom; },
          dy: '.35em',
          class: 'barGameLabel',
          'font-weight': 'bold',
        })
        .text(function(d) { return d.value; });

      gameTGvis
        .append('line')
        .attr({
          x1: gameTGMargins.left,
          x2: dashBoardWidth - gameTGMargins.right,
          y1: Math.floor(yGameTG(820)) + gameTGMargins.top,
          y2: Math.floor(yGameTG(820)) + gameTGMargins.top,
          stroke: okYellow,
          'stroke-width': 2,
        });

      gameStatsTG
        .exit()
        .remove();
      gameStatLabelsTG
        .exit()
        .remove();
    }

    var getPlayerInfo = function(d, seasonGames) {
      var result = { name: 'Russell Westbrook' };
      var games = totalGames;
      var points = totalPoints;
      var assists = totalAssists;
      var rebounds = totalRebounds;
      
      result['total'] = [
        { name: 'Игр', value: games },
        { name: 'Очков', value: points },
        { name: 'Передач', value: assists },
        { name: 'Подборов', value: rebounds },
      ];
      result['perGame'] = [
        { name: 'В среднем', value: '' },
        { name: 'Очков', value: (points / games).toFixed(1) },
        { name: 'Передач', value: (assists / games).toFixed(1) },
        { name: 'Подборов', value: (rebounds / games).toFixed(1) },
      ];
      result['leftToScore'] = [
        { name: 'Осталось', value: '' },
        { name: 'Очков', value: Math.max(seasonGames * 10 - points, 0) },
        { name: 'Передач', value: Math.max(seasonGames * 10 - assists, 0) },
        { name: 'Подборов', value: Math.max(seasonGames * 10 - rebounds, 0) },
      ];
      result['rythm'] = [
        { name: 'В том же темпе', value: '' },
        { name: 'Очков', value: Math.floor(seasonGames * points / games) },
        { name: 'Передач', value: Math.floor(seasonGames * assists / games) },
        { name: 'Подборов', value: Math.floor(seasonGames * rebounds / games) },
      ];
      result['perGameLeft'] = [
        { name: 'Нужно в том же темпе за игру', value: '' },
        { name: 'Очков', value: (Math.max(seasonGames * 10 - points, 0) / (seasonGames > games ? seasonGames - games : 1)).toFixed(1) },
        { name: 'Передач', value: (Math.max(seasonGames * 10 - assists, 0) / (seasonGames > games ? seasonGames - games : 1)).toFixed(1) },
        { name: 'Подборов', value: (Math.max(seasonGames * 10 - rebounds, 0) / (seasonGames > games ? seasonGames - games : 1)).toFixed(1) },
      ];
      return result;
    };
  </script>
</body>
</html>